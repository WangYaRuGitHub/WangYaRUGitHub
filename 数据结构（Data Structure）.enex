<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20201111T143714Z" application="Evernote/Windows" version="6.x">
<note><title>数据结构（Data Structure）</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><div><font face="仿宋" style="font-size: 10pt;">数据结构（Data Structure）&nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;">对数据进行组织管理</font></div><div><font face="仿宋" style="font-size: 10pt;">线性&nbsp; &nbsp; 树形&nbsp; &nbsp;图形</font></div><div><font face="仿宋" style="font-size: 10pt;">衡量标准：复杂度</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 评估运行时间：时间复杂度</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 评估运行所需时间：空间复杂度</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 不是静态的，而是评估</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">课程内容包括：</font></div><div><font face="仿宋" style="font-size: 10pt;">1、数据结构理论</font></div><div><font face="仿宋" style="font-size: 10pt;">线性表（顺序表+链表）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 栈和队列</font></div><div><font face="仿宋" style="font-size: 10pt;">树形结构（二叉树--遍历）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 层序遍历（前中后）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 非层序遍历</font></div><div><font face="仿宋" style="font-size: 10pt;">堆</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">排序算法</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">两个常见的搜索树结构（搜索树+哈希表）</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">2、JDK中提供的常见数据结构实现-----java集合类（Collection Framework）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;2.1&nbsp;类（接口）的关系&nbsp; &nbsp;&nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;">I表示接口（Interface ）&nbsp; &nbsp;C表示类(Class)</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Iterable(I)</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Collection(I)</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <span style="font-weight: bold;">List(I)</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span style="font-weight: bold;">&nbsp; Queue(I)</span><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</span> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span style="font-weight: bold;">&nbsp; &nbsp;</span><span style="font-weight: bold;">&nbsp;</span><span style="font-weight: bold;">Set(I)</span></font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;PriorityQueue(C)</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Deque(I)</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">ArrayList(I)&nbsp; &nbsp;LinkedList(I)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ArrayDeque(C)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;TreeSet(C)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HashSet(C)</font></div><div><font face="仿宋" style="font-size: 10pt;">顺序表&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 链表&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;循环数组双端队列&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 红黑树&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 哈希表</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Map(I)</span></font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">TreeMap(C)&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; HashMap(C)</font></div><div><font face="仿宋" style="font-size: 10pt;">红黑树&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 哈希表</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">Iterator(I)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Arrays(C)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Collections(C)</font></div><div><font face="仿宋" style="font-size: 10pt;">迭代器&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 数组方法集&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 集合方法集</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">前提：</font></div><div><font face="仿宋" style="font-size: 10pt;">1、对象的比较能力</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp;==&nbsp; &nbsp;!=&nbsp; &lt;=&nbsp; &gt;=&nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;equals&nbsp; Comparator Comparable</font></div><div><font face="仿宋" style="font-size: 10pt;">2、泛型</font></div><div><font face="仿宋" style="font-size: 10pt;">3、常见面试题：</font></div><div><font face="仿宋" style="font-size: 10pt;">链表</font></div><div><font face="仿宋" style="font-size: 10pt;">栈和队列</font></div><div><font face="仿宋" style="font-size: 10pt;">二叉树</font></div><div><font face="仿宋" style="font-size: 10pt;">其他</font></div><div><font face="仿宋" style="font-size: 10pt;">4、提升写代码的能力</font></div><hr/><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><hr/><div><font face="仿宋" style="font-size: 10pt;"><span style="font-weight: bold;">具体复习</span></font></div><div><span style="font-weight: bold;"><font face="仿宋" style="font-size: 10pt;">一、线性表</font></span></div><div><font face="仿宋" style="font-size: 10pt;">对引用和对象的理解一定要清楚</font></div><div><font face="仿宋" style="font-size: 10pt;">常见面试题</font></div><div><font face="仿宋" style="font-size: 10pt;">顺序表和链表的区别(ArrayList和LinkedList的区别)</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp;1、&nbsp; 随机访问的区别，顺序表的时间复杂度是O(1)，链表的时间复杂度是O(n)</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;2、 顺序表总会留一段空间是不存的，链表除了保存自身以外还要保存其他的，每个节点总会浪费一点空间</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp;&nbsp; &nbsp;3、 链表定位到节点的前提下：插入、删除是O(1)但定位结点往往是O(n)</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;顺序表：头插、中间插入O(n)&nbsp; &nbsp;尾插O（1）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;4、都不是线程安全的----Vector是线程安全的</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">方法的使用（会用会实现）</font></div><div><font face="仿宋" style="font-size: 10pt;">add(e)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 尾插&nbsp; 时间复杂度&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 顺序表O(1)&nbsp; &nbsp; 链表O(1)</font></div><div><font face="仿宋" style="font-size: 10pt;">add(index,e)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;插入到index位置&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; O(n)</font></div><div><font face="仿宋" style="font-size: 10pt;">add(0,e)&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 头插&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ArrayList:O(n)&nbsp; &nbsp;LinkedList:O(1)</font></div><div><font face="仿宋" style="font-size: 10pt;">remove(e)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 删除e元素&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;O(n) （查找删除后需要把后面的节点移过来）&nbsp; &nbsp;&nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;">remove(index)&nbsp; &nbsp; &nbsp;删除index位置&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;O(n)</font></div><div><font face="仿宋" style="font-size: 10pt;">get（index）&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;获取index位置的元素&nbsp;&nbsp;&nbsp;&nbsp;A：O(1)&nbsp; L:O(n)</font></div><div><font face="仿宋" style="font-size: 10pt;">set(index,e)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 替换index位置的元素 &nbsp;&nbsp; &nbsp;A：O(1) L:O(N)</font></div><div><font face="仿宋" style="font-size: 10pt;">contains(e)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;查找：注意要点equals&nbsp; O(n)</font></div><div><font face="仿宋" style="font-size: 10pt;">isempty size clear</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;">xxxAll&nbsp; &nbsp; ArrayList</font></div><div><font face="仿宋" style="font-size: 10pt;">Set&lt;Integer&gt; set = ...;</font></div><div><font face="仿宋" style="font-size: 10pt;">List&lt;Integer&gt; list = new ArrayList(set)</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">实现：</font></div><div><font face="仿宋" style="font-size: 10pt;">1、ArrayList&nbsp;自己实现（延迟加载）</font></div><div><font face="仿宋" style="font-size: 10pt;">2、LinkedList&nbsp;自己实现 （双向的，保存头+尾结点的链表）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; 备注：区分&nbsp; 元素&nbsp; &nbsp; 节点&nbsp; &nbsp;链表</font></div><div><font face="仿宋" style="font-size: 10pt;">小tips：延迟加载&nbsp; &nbsp; 按需加载&nbsp; &nbsp;lazy&nbsp;load&nbsp;&nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><hr/><hr/><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">链表面试题</font></div><div><font face="仿宋" style="font-size: 10pt;">1、链表反转</font></div><div><font face="仿宋" style="font-size: 10pt;">2、两个有序链表合并</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">队列（Deque）&nbsp; &nbsp; &nbsp;FIFO&nbsp; &nbsp;（BFS）</font></div><div><font face="仿宋" style="font-size: 10pt;">add/remove/element</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">栈（Stack）&nbsp; &nbsp; &nbsp; &nbsp;FILO&nbsp; &nbsp;LIFO(用来颠倒顺序)&nbsp; &nbsp;DFS</font></div><div><font face="仿宋" style="font-size: 10pt;">push/pop/peek</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">List(I)</font></div><div><font face="仿宋" style="font-size: 10pt;">Vector(C)</font></div><div><font face="仿宋" style="font-size: 10pt;">Stack(C)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><hr/><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">二叉树</font></div><div><font face="仿宋" style="font-size: 10pt;">1、概念：满二叉树&nbsp; 完全二叉树</font></div><div><font face="仿宋" style="font-size: 10pt;">2、树的遍历</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp;前序|中序|后序&nbsp; &nbsp;递归</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 非递归</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; 层序遍历</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;90%的题都是前中后序的变形</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;一种是遍历的思路，一种是化解子问题的思路</font></div><div><font face="仿宋" style="font-size: 10pt;">3、递归的理解</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp;&nbsp;</font></div><hr/><div><font face="仿宋" style="font-size: 10pt;">堆：是一种有特殊用途的数据结构</font></div><div><font face="仿宋" style="font-size: 10pt;">为什么要用到堆：为了多次取最值</font></div><div><font face="仿宋" style="font-size: 10pt;">理解什么是堆：逻辑上是完全二叉树，存储上是数组，下标的关系</font></div><div><font face="仿宋" style="font-size: 10pt;">方法：向下调整+建堆</font></div><div><font face="仿宋" style="font-size: 10pt;">面试题：TopK</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">搜索专用数据结构：</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp;平衡搜索树+哈希表</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; 1、平衡搜索树--基于比较；中序有序（Key&nbsp;的顺序）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp;使用TreeSet/TreeMap的时候，需要保证&nbsp;元素/key&nbsp;具备比较的能力</font></div><div><font face="仿宋" style="font-size: 10pt;">JDK&nbsp; TreeSet/TreeMap&nbsp;对应红黑树</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">2、哈希表（重点中的重点）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp;什么是哈希表（数组+哈希函数）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp;什么是哈希函数（把对象变成int类型，把int类型变成合法下标）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp;哈希冲突：不同的对象具有相同的int</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp;哈希冲突理论上是不可避免的-----鸽笼定理（抽屉定理）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp;哈希冲突的解决办法</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;线性探测法（开放寻址法）</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用另一个数据结构存储冲突元素（单链块--&gt;红黑树）&nbsp; java</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp;put过程/插入过程</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp;调用对象的HashCode()&nbsp; 对象--&gt;int</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp;把int类型变成合法的下标</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; 取模的方式</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; JDK的方式---前提：数组长度，一定是2的n次方</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n是数组长度 h是hashCode的结果&nbsp; &nbsp;h&amp;(n-1)&nbsp; &nbsp;&nbsp;</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; &nbsp;比如 n = 8&nbsp; &nbsp;1000</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; &nbsp;n-1 = 7&nbsp; &nbsp; &nbsp; &nbsp;0111</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; &nbsp;任意数&amp;0111得到的一定是[0,7]，一定是合法下标</font></div><div><font face="仿宋" style="font-size: 10pt;"><br/></font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; 优点：比取模快（取模有余数）</font></div><div><font face="仿宋" style="font-size: 10pt;">3、在index位置对应的链表中查找key</font></div><div><font face="仿宋" style="font-size: 10pt;">4、在链表中插入</font></div><div><font face="仿宋" style="font-size: 10pt;">5、通过控制负载因子，来调节哈希表的冲突率</font></div><div><font face="仿宋" style="font-size: 10pt;">6、再次强调，重点！HashMap的插入过程（必须代码写了+可以口述过程）</font></div><div><font face="仿宋" style="font-size: 10pt;">7、哈希冲突：</font></div><div><font face="仿宋" style="font-size: 10pt;">&nbsp; &nbsp; &nbsp; 不可避免、可以解决、尽量降低（函数函数的设计、理论上，数组长度可以用素数（java不是，数组长度是2的n次方；设置一个负载因子的阈值，通过扩容，来降低冲突率））</font></div><div><font face="仿宋" style="font-size: 10pt;">8、如果真的遇到链表长度过长了（8为什么是8？泊松分布，算下来，8的概率是6、一亿），把链表转换成红黑树</font></div><div><font face="仿宋" style="font-size: 10pt;">9、HashMap不是线程安全的，ConcurrentHashMap&nbsp;是线程安全的</font></div><div><font face="仿宋" style="font-size: 10pt;">10、自定义类作为Ha